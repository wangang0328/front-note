# 浏览器相关的知识点

## 一些面试题

### js的事件循环机制

微任务： requestAnimationFrame() promise  fetch

浏览器中每个渲染进程都有一个主线程，处理各种事件，要想让这么多任务在主线程有条不紊的执行，就需要一个系统来调度这些任务，这个系统就是消息队列和事件循环系统。

渲染进程中所有运行在主线程上的任务都需要先添加到消息队列，然后事件循环系统再按照顺序执行消息队列中的任务。

1. 添加一个消息队列
2. IO线程中产生的新任务添加到消息队列的尾部
3. 渲染主线程会循环的从消息队列头部中读取任务，执行任务
4. 当其他进程发送过来任务，渲染进程中的IO线程用来接受其他进程传进来的消息，接收到消息之后，放入到消息队列。

普通任务会添加到消息队列，异步任务放入到异步队列。

微任务添加到当前任务的微任务队列中

消息队列中的任务都是宏任务，每个宏任务中有一个微任务队列，

**事件循环机制:**

概括的来说：执行宏任务 执行微任务列表、执行宏任务 执行微任务列表

1. 将同步任务添加到消息队列中，异步任务添加到异步队列中

2. 渲染主线程循环的从消息队列头部中读取任务，执行任务，

3. 执行当前宏任务前，从当前宏任务的微任务队列中读取任务并执行。执行完之后读取消息队列的下一个宏任务

4. 当循环队列消息为空时，执行异步队列到期任务

5. 以上过程不断的重复。成为Event Loop(事件循环)

   宏任务是指？整体script作为第一个宏任务进入主线程

### 在浏览器里，从输入URL到页面展示，这中间发生了什么？

1. 用户地址栏输入关键字

      地址栏会判断输入的关键字是**搜索内容**， 还是**请求的URL**

   - 内容是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的URL
   - 内容是符合URL规则的，根绝规则合成完整的URL，补全完整的URL

2. 浏览器进程通过进程间通信(IPC)把url请求发送给网络进程

3. 网络进程接收到url请求后检查本地是否缓存了该请求资源，如果有则将该缓存资源返回给浏览器进程

4. 如果没有，网络进程向web服务器发起http请求(网络请求)，请求流程如下

   - 系统会自动从hosts文件中寻找对应的ip地址，一旦找到域名对应的ip地址，和服务器创建TCP连接，没找到，系统会将网址提交DNS域名解析服务器，获取服务器的ip地址
   - 利用ip地址和服务器建立tcp链接(三次握手)
   - 建立链接后，浏览器构建数据包(包含请求头，请求行，请求正文，并把该域名相关cookie等数据附加到请求头)，然后向服务器发送请求头信息
   - 服务器接收到消息后根据请求信息构建响应数据(包含响应行，响应头，响应正文)，然后发送回网络进程
   - 网络进程接收到响应数据后进行解析。如果返回的状态码为301(永久),302，需要重定向，重定向的url地址在响应头中Location字段中。一切重新来。
   - 获取到的数据以什么方式打开？打开的方式就是Content-Type。这个属性告诉浏览器返回的数据是什么类型的。如果是网页类型text/html, 如果是下载文件类型：application/octet-stream等。如果是下载类型，则该请求会被提交给浏览器的下载管理器，同时该请求流程结束。如果是网页类型，那么该浏览器就要准备渲染页面了
   
5. 渲染页面开始。浏览器发出“提交文档”（文档是响应体数据）消息给渲染进程，渲染进程接收到消息后会和网络进程建立管道，网络进程将“文档”传输给渲染进程

6. 传输完毕，渲染进程会发出“确认提交”消息给浏览器进程

7. 浏览器在接收到“确认提交”消息后，更新浏览器界面状态(包括地址栏URL，安全状态，前进后退的历史状态)，并更新web页面。

8. 开始渲染

   - DOM生成；渲染进程将HTML内容转为能够读懂的**DOM树**结构
   - 样式计算；渲染引擎将CSS样式表转为浏览器可以理解的**styleSheets**, 计算出DOM节点的样式
   - 布局；创建布局树，计算每个元素的几何坐标位置，将这些信息保存在局部树中。
   - 分层；对布局树进行分层，并生成**分层树**；浏览器页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。1. 拥有层叠上下文属性的元素会被提升为单独的一层（z-index,opacity,filter,position等），需要裁剪的地方也会被创建为图层
   - 图层；为每个图层生成**绘制列表**，并将其提交到合成线程。
   - 合成线程将图层分成**图块**，并在**光栅化线程池**中将图快转换成位图
   - 合成线程发送绘制图块命令**DrawQuad**给浏览器进程
   - 浏览器进程根据DrawQuad消息**生成页面**，并**显示**到显示器上

9. 渲染阶段，一旦文档被提交，渲染进程开始页面解析和子资源加载。一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器进程接收到消息后，会停止图标上的加载动画。

10. 至此，一个页面也就生成了

### TCP的三次握手和四次挥手

#### 三次握手

1. 客户端发送一个带有SYN标志的数据包
2. 服务端给客户端发送带有SYN和ACK标志的数据包
3. 客户端给服务端发送带有ACK标志的数据包

至此，建立链接

#### 四次挥手

四次挥手就是TCP连接的释放。连接的释放必须是一方主动释放，另一方被动释放。

1. 客户端想要释放连接，向服务端发送一段TCP报文，标记FIN，表示请求释放连接
2. 服务端接收到客户端发出的TCP报文之后，确认了客户端想要释放连接。进入CLOSE-WAIT阶段(半关闭状态)并范围ACK标记的数据包，表示接收到了客户端发送的释放连接请求， 随后服务端开始准备释放服务端到客户端方向上的连接
3. 服务端自从发出ACK确认报文之后，经过CLOSE-WAIT阶段，做好了释放服务端到客户端释放连接的准备，再次向客户端发出一段带有ACK标记的TCP报文，并不是确认收到服务端报文 的确认报文。此时停止服务端到客户端发送数据，但是可以接收客户端上的数据。
4. 客户端接收到服务端发出的TCP报文，确认了服务端已经做好释放连接的准备，客户端向服务端发送带有ACK标记的报文， 然后进入TIME-WAIT阶段，等待2MSL之后，进入CLOSED阶段。

### 定时器的执行顺序或机制 

浏览器页面是有消息队列和事件循环系统来驱动的

（chrome 中有另外一个消息队列，这个队列用来维护需要延迟执行的任务列表。包括定时器和Chromium内部一些需要延迟执行的任务）

js创建一个定时器时，会将该回调任务任务（回调函数的名称，当前发起时间，延迟执行时间）添加到延时队列中。ProcessDelayTask函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。任务执行完之后，开始执行下一个循环。

### 重排，重绘，合成

- 更新了元素的几何属性(重排)

  通过js或css改变元素的几何位置属性，例如改变元素的宽度和高度等。那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。**重排需要更新完整的渲染流水线，所以开销也是最大的**

- 更新元素的绘制属性(重绘)

  比如改变了元素的颜色，那么布局阶段不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程叫做**重绘**。**重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些**

- 直接合成

​       如果更改一个既不要布局也不要绘制的属性，浏览器将跳过布局和绘制，只执行后续的合成操作，这个过程称为合成。比如transform。合成的效率最高

### 跨标签页通信

不同标签页的通讯，本质原理就是去运用一些可以共享的中间介质， 

- 通过父页面`window.open()`和子页面`postMessage`
- 设置同域下共享的`localStorage`与监听`window.onstorage`
  - 重复写入相同的值无法触发
  - 会受到浏览器隐身模式等的限制
- 设置共享cookie与不断轮询脏查询(setInterval)
- 借助服务器端或者中间层实现





